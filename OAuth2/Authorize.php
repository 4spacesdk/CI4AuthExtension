<?php namespace AuthExtension\OAuth2;

use AuthExtension\AuthExtension;
use AuthExtension\Entities\User;
use CodeIgniter\HTTP\Response;
use Exception;
use OAuth2\RequestInterface;

/**
 * Class Authorize
 * @package AuthExtension\OAuth2
 */
class Authorize {

    /**
     * @param Response $response
     */
    public static function handle($response) {
        $oauthResponse = new \OAuth2\Response();
        $request = \OAuth2\Request::createFromGlobals();
        $server = ServerLib::getInstance()->server;

        // Validates the authorize request. If it is invalid, redirects back to the client with the errors.
        if(!$server->validateAuthorizeRequest($request, $oauthResponse)) {
            $response->setStatusCode($oauthResponse->getStatusCode());
            $response->setJSON($oauthResponse->getResponseBody());
            $response->send();
            return;
        }

        // Stores the request
        session()->setFlashdata('request', $request);

        // Session Check
        $sessionCheck = AuthExtension::checkSession();

        // Check user scopes
        $requestedScope = $request->request('scope', $request->query('scope'));
        if ($sessionCheck) {
            if ($requestedScope) {
                $userScopes = $sessionCheck->scope;
                if (!$server->getScopeUtil()->checkScope($requestedScope, $userScopes)) {
                    $sessionCheck = false;
                }
            }
        }

        // Silent renew.
        // The Authorization Server MUST NOT display any authentication or consent user interface pages.
        $prompt = $request->query('prompt');
        if($prompt && $prompt == 'none') {
            if($sessionCheck) {
                self::authorizePost($response, true);
                return;
            } else {
                $response->redirect($request->query['redirect_uri']);
                return;
            }
        }

        // Authenticates End-User.
        // http://openid.net/specs/openid-connect-implicit-1_0.html#Authenticates
        if(!$sessionCheck) {
            // Stores the request.
            $redirectUri = base_url('/authorize') . '?' . $_SERVER['QUERY_STRING'];
            session()->setFlashdata('requestUrl', $redirectUri);
            // Redirects to login.
            $response->redirect(base_url('/login') . '?scope='.$requestedScope);
            return;
        }

        self::authorizePost($response, true);
    }

    /**
     * @param Response $response
     * @param bool $no_prompt
     */
    private static function authorizePost($response, $no_prompt = false) {
        // Gets the request.
        /** @var RequestInterface $request */
        $request = session()->getFlashdata('request');
        $oauthResponse = new \OAuth2\Response();
        $is_authorized = isset($_POST['authorize']) || $no_prompt;

        $sessionCheck = AuthExtension::checkSession();
        if($sessionCheck)
            ServerLib::getInstance()->server->handleAuthorizeRequest($request, $oauthResponse, $is_authorized, $sessionCheck->id);

        // Session management:
        // http://openid.net/specs/openid-connect-session-1_0.html#CreatingUpdatingSessions
        // "opbs" is the cookie generated by Ion Auth 2 for user session,
        // ("remember_cookie_name" in config),
        // alternatively it would be possible to generate a base64 token: "$this->base64url_encode(random_bytes(64));"
        // and manage it manually.
        helper('cookie');
        $browser_state = get_cookie('opbs');
        try {
            $session_state = self::calculateSessionState($request, $browser_state);
            $header = $oauthResponse->getHttpHeader('Location');
            $header = $header . '&session_state=' . $session_state;
            $response->redirect($header);
        } catch(Exception $e) {
            $oauthResponse->setError(500, $e->getMessage());
            $response->setStatusCode($oauthResponse->getStatusCode());
            $response->setJSON($oauthResponse->getResponseBody());
            $response->send();
        }
    }

    /**
     * @param RequestInterface $request
     * @param $browser_state
     * @return string
     * @throws Exception
     */
    private static function calculateSessionState($request, $browser_state) {
        $client_id = $request->query('client_id');
        // Redirect URI in the request is different for silent renew.
        $client_details = ServerLib::getInstance()->server->getStorage('client')->getClientDetails($client_id);
        $origin = $client_details['redirect_uri'];
        $salt = rtrim(strtr(base64_encode(random_bytes(16)), '+/', '-_'), '=');
        $hash = hash('sha256', sprintf('%s%s%s%s', $client_id, $origin, $browser_state, $salt));
        return sprintf('%s.%s', $hash, $salt);
    }

}
