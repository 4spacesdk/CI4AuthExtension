<?php namespace AuthExtension\OAuth2;

use AuthExtension\AuthExtension;
use CodeIgniter\HTTP\ResponseInterface;
use Exception;
use OAuth2\Request;
use OAuth2\RequestInterface;
use OAuth2\Response;

class Authorize {

    public static function handle(ResponseInterface $response): void {
        $request = Request::createFromGlobals();
        $oauthResponse = new Response();

        $server = ServerLib::getInstance()->server;
        // Validates the authorize request. If it is invalid, redirects back to the client with the errors.
        if (!$server->validateAuthorizeRequest($request, $oauthResponse)) {
            $response->setStatusCode($oauthResponse->getStatusCode());
            $response->setJSON($oauthResponse->getResponseBody());
            $response->send();
            return;
        }

        // Stores the request
        session()->setFlashdata('request', $request);

        // Session Check
        $sessionCheck = AuthExtension::checkSession();

        // Check user scopes
        $requestedScope = $request->request('scope', $request->query('scope'));
        if ($sessionCheck) {
            if ($requestedScope) {
                $userScopes = implode(' ', array_merge(['openid', 'offline_access'], explode(' ', $sessionCheck->scope)));
                if (!$server->getScopeUtil()->checkScope($requestedScope, $userScopes)) {
                    $sessionCheck = false;
                }
            }
        }

        // Silent renew.
        // The Authorization Server MUST NOT display any authentication or consent user interface pages.
        $prompt = $request->query('prompt');
        if ($prompt && $prompt == 'none') {
            if ($sessionCheck) {
                self::authorizePost($response, true);
                return;
            } else {
                $response->redirect($request->query['redirect_uri']);
                return;
            }
        }

        // Authenticates End-User.
        // http://openid.net/specs/openid-connect-implicit-1_0.html#Authenticates
        if (!$sessionCheck) {
            // Stores the request.
            $redirectUri = base_url('/authorize') . '?' . $_SERVER['QUERY_STRING'];
            session()->setFlashdata('requestUrl', $redirectUri);
            // Redirects to login.
            /** @var \Config\AuthExtension $authConfig */
            $authConfig = config('AuthExtension');
            $response->redirect(base_url($authConfig->loginPage) . '?scope=' . $requestedScope);
            return;
        }

        self::authorizePost($response, true);
    }

    private static function authorizePost(ResponseInterface $response, bool $no_prompt = false): void {
        // Gets the request.
        /** @var RequestInterface $request */
        $request = session()->getFlashdata('request');
        $oauthResponse = new Response();
        $is_authorized = isset($_POST['authorize']) || $no_prompt;

        $sessionCheck = AuthExtension::checkSession();
        if ($sessionCheck) {
            ServerLib::getInstance()->server->handleAuthorizeRequest($request, $oauthResponse, $is_authorized, $sessionCheck->id);
        }

        // Session management:
        // http://openid.net/specs/openid-connect-session-1_0.html#CreatingUpdatingSessions
        // "opbs" is the cookie generated by Ion Auth 2 for user session,
        // ("remember_cookie_name" in config),
        // alternatively it would be possible to generate a base64 token: "$this->base64url_encode(random_bytes(64));"
        // and manage it manually.
        helper('cookie');
        $browser_state = get_cookie('opbs');
        try {
            $session_state = self::calculateSessionState($request, $browser_state);
            $header = $oauthResponse->getHttpHeader('Location');
            $header = $header . '&session_state=' . $session_state;
            $response->redirect($header);
        } catch (Exception $e) {
            $oauthResponse->setError(500, $e->getMessage());
            $response->setStatusCode($oauthResponse->getStatusCode());
            $response->setJSON($oauthResponse->getResponseBody());
            $response->send();
        }
    }

    /**
     * @param RequestInterface $request
     * @param $browser_state
     * @return string
     * @throws Exception
     */
    private static function calculateSessionState($request, $browser_state): string {
        $client_id = $request->query('client_id');
        // Redirect URI in the request is different for silent renew.
        $client_details = ServerLib::getInstance()->server->getStorage('client')->getClientDetails($client_id);
        $origin = $client_details['redirect_uri'];
        $salt = rtrim(strtr(base64_encode(random_bytes(16)), '+/', '-_'), '=');
        $hash = hash('sha256', sprintf('%s%s%s%s', $client_id, $origin, $browser_state, $salt));
        return sprintf('%s.%s', $hash, $salt);
    }

}
